<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractDnsNodeRepository.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dc-con-app</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.dccon.repository</a> &gt; <span class="el_source">AbstractDnsNodeRepository.java</span></div><h1>AbstractDnsNodeRepository.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.dccon.repository;

import static org.bremersee.dccon.model.UnknownFilter.ALL;
import static org.bremersee.dccon.model.UnknownFilter.NO_UNKNOWN;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import lombok.AccessLevel;
import lombok.Getter;
import org.bremersee.data.ldaptive.LdaptiveTemplate;
import org.bremersee.dccon.config.DomainControllerProperties;
import org.bremersee.dccon.model.DhcpLease;
import org.bremersee.dccon.model.DnsNode;
import org.bremersee.dccon.model.DnsPair;
import org.bremersee.dccon.model.DnsRecord;
import org.bremersee.dccon.model.DnsZone;
import org.bremersee.dccon.model.UnknownFilter;
import org.springframework.util.StringUtils;

/**
 * The abstract dns node repository.
 *
 * @author Christian Bremer
 */
public abstract class AbstractDnsNodeRepository extends AbstractRepository
    implements DnsNodeRepository {

<span class="fc" id="L51">  @Getter(AccessLevel.PACKAGE)</span>
  private final DhcpRepository dhcpRepository;

<span class="fc" id="L54">  @Getter(AccessLevel.PACKAGE)</span>
  private final DnsZoneRepository dnsZoneRepository;

<span class="nc" id="L57">  @Getter(AccessLevel.PACKAGE)</span>
  private final List&lt;Pattern&gt; excludedNodeNamePatterns;

<span class="nc" id="L60">  @Getter(AccessLevel.PACKAGE)</span>
  private final Pattern patternIp4;

  /**
   * Instantiates a new abstract repository.
   *
   * @param properties the properties
   * @param ldapTemplate the ldap template
   * @param dhcpRepository the dhcp repository
   * @param dnsZoneRepository the dns zone repository
   */
  AbstractDnsNodeRepository(
      final DomainControllerProperties properties,
      final LdaptiveTemplate ldapTemplate,
      final DhcpRepository dhcpRepository,
      final DnsZoneRepository dnsZoneRepository) {

<span class="fc" id="L77">    super(properties, ldapTemplate);</span>
<span class="fc" id="L78">    this.dhcpRepository = dhcpRepository;</span>
<span class="fc" id="L79">    this.dnsZoneRepository = dnsZoneRepository;</span>
<span class="fc" id="L80">    this.excludedNodeNamePatterns = properties.getExcludedNodeRegexList().stream()</span>
<span class="fc" id="L81">        .map(Pattern::compile)</span>
<span class="fc" id="L82">        .collect(Collectors.toList());</span>
<span class="fc" id="L83">    this.patternIp4 = Pattern.compile(properties.getIp4Regex());</span>
<span class="fc" id="L84">  }</span>

  /**
   * Is non excluded dns node boolean.
   *
   * @param dnsNode the dns node
   * @return the boolean
   */
  boolean isNonExcludedDnsNode(final DnsNode dnsNode) {
<span class="pc bpc" id="L93" title="2 of 4 branches missed.">    return dnsNode != null &amp;&amp; !isExcludedDnsNode(dnsNode);</span>
  }

  /**
   * Is non excluded dns node boolean.
   *
   * @param dnsNodeName the dns node name
   * @return the boolean
   */
  boolean isNonExcludedDnsNode(final String dnsNodeName) {
<span class="pc bpc" id="L103" title="2 of 4 branches missed.">    return dnsNodeName != null &amp;&amp; !isExcludedDnsNode(dnsNodeName);</span>
  }

  /**
   * Is excluded dns node boolean.
   *
   * @param dnsNode the dns node
   * @return the boolean
   */
  boolean isExcludedDnsNode(final DnsNode dnsNode) {
<span class="pc bpc" id="L113" title="1 of 4 branches missed.">    return dnsNode != null &amp;&amp; isExcludedDnsNode(dnsNode.getName());</span>
  }

  /**
   * Is excluded dns node boolean.
   *
   * @param dnsNodeName the dns node name
   * @return the boolean
   */
  boolean isExcludedDnsNode(final String dnsNodeName) {
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">    return dnsNodeName != null &amp;&amp; excludedNodeNamePatterns.stream()</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        .anyMatch(pattern -&gt; pattern.matcher(dnsNodeName).matches());</span>
  }

  @Override
  public List&lt;DnsNode&gt; findByIps(final Set&lt;String&gt; ips, final UnknownFilter unknownFilter) {
<span class="nc" id="L129">    final List&lt;DnsNode&gt; nodes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">    for (DnsZone zone : dnsZoneRepository.findNonDnsReverseZones().collect(Collectors.toList())) {</span>
<span class="nc" id="L131">      for (DnsNode node : findAll(zone.getName(), unknownFilter, null)</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">          .collect(Collectors.toList())) {</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">        for (DnsRecord record : node.getRecords()) {</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">          if (DnsRecordType.A.is(record.getRecordType())</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">              &amp;&amp; ips.contains(record.getRecordValue())) {</span>
<span class="nc" id="L136">            nodes.add(node);</span>
          }
<span class="nc" id="L138">        }</span>
<span class="nc" id="L139">      }</span>
<span class="nc" id="L140">    }</span>
<span class="nc" id="L141">    return nodes;</span>
  }

  @Override
  public Optional&lt;DnsNode&gt; findByHostName(
      final String hostName,
      final UnknownFilter unknownFilter) {

<span class="fc" id="L149">    final List&lt;String&gt; zoneNames = dnsZoneRepository.findNonDnsReverseZones()</span>
<span class="fc" id="L150">        .map(DnsZone::getName)</span>
<span class="fc" id="L151">        .sorted((o1, o2) -&gt; {</span>
<span class="nc" id="L152">          int n1 = StringUtils.countOccurrencesOf(o1, &quot;.&quot;);</span>
<span class="nc" id="L153">          int n2 = StringUtils.countOccurrencesOf(o2, &quot;.&quot;);</span>
<span class="nc" id="L154">          return n2 - n1;</span>
        })
<span class="fc" id="L156">        .collect(Collectors.toList());</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">    for (String zoneName : zoneNames) {</span>
<span class="fc" id="L158">      final String suffix = &quot;.&quot; + zoneName;</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">      if (hostName.endsWith(suffix)) {</span>
<span class="nc" id="L160">        final String name = hostName.substring(0, hostName.length() - suffix.length());</span>
<span class="nc" id="L161">        return findOne(zoneName, name, unknownFilter);</span>
      }
<span class="fc" id="L163">    }</span>
<span class="fc" id="L164">    return findOne(getProperties().getDefaultZone(), hostName, unknownFilter);</span>
  }

  /**
   * Is query result boolean.
   *
   * @param dnsNode the dns node
   * @param query the query
   * @return the boolean
   */
  boolean isQueryResult(final DnsNode dnsNode, final String query) {
<span class="pc bpc" id="L175" title="3 of 6 branches missed.">    return query != null &amp;&amp; query.length() &gt; 2 &amp;&amp; dnsNode != null</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        &amp;&amp; (contains(dnsNode.getName(), query)</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        || isQueryResult(dnsNode.getRecords(), query));</span>
  }

  /**
   * Is query result boolean.
   *
   * @param dnsRecords the dns records
   * @param query the query
   * @return the boolean
   */
  boolean isQueryResult(final Collection&lt;DnsRecord&gt; dnsRecords, final String query) {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">    if (dnsRecords != null) {</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">      for (DnsRecord dnsRecord : dnsRecords) {</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (isQueryResult(dnsRecord, query)) {</span>
<span class="fc" id="L191">          return true;</span>
        }
<span class="nc" id="L193">      }</span>
    }
<span class="nc" id="L195">    return false;</span>
  }

  /**
   * Is query result boolean.
   *
   * @param dnsRecord the dns record
   * @param query the query
   * @return the boolean
   */
  boolean isQueryResult(final DnsRecord dnsRecord, final String query) {
<span class="pc bpc" id="L206" title="3 of 6 branches missed.">    return query != null &amp;&amp; query.length() &gt; 2 &amp;&amp; dnsRecord != null</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        &amp;&amp; (contains(dnsRecord.getRecordValue(), query)</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        || contains(dnsRecord.getCorrelatedRecordValue(), query)</span>
<span class="pc bnc" id="L209" title="All 2 branches missed.">        || isQueryResult(dnsRecord.getDhcpLease(), query));</span>
  }

  /**
   * Is query result boolean.
   *
   * @param dhcpLease the dhcp lease
   * @param query the query
   * @return the boolean
   */
  boolean isQueryResult(final DhcpLease dhcpLease, final String query) {
<span class="nc bnc" id="L220" title="All 6 branches missed.">    return query != null &amp;&amp; query.length() &gt; 2 &amp;&amp; dhcpLease != null</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        &amp;&amp; (contains(dhcpLease.getHostname(), query)</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        || contains(dhcpLease.getIp(), query)</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        || contains(dhcpLease.getMac(), query)</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        || contains(dhcpLease.getManufacturer(), query));</span>
  }

  /**
   * Find one optional.
   *
   * @param zoneName the zone name
   * @param nodeName the node name
   * @param unknownFilter the unknown filter
   * @param withCorrelationValues the with correlation values
   * @param withDhcpLeases the with dhcp leases
   * @return the optional
   */
  abstract Optional&lt;DnsNode&gt; findOne(
      String zoneName,
      String nodeName,
      UnknownFilter unknownFilter,
      boolean withCorrelationValues,
      boolean withDhcpLeases);

  @Override
  public Optional&lt;DnsNode&gt; findOne(
      final String zoneName,
      final String nodeName,
      final UnknownFilter unknownFilter) {
<span class="fc" id="L249">    return findOne(zoneName, nodeName, unknownFilter, true, true);</span>
  }

  /**
   * Insert dhcp leases dns node.
   *
   * @param zoneName the zone name
   * @param dnsNode the dns node
   * @return the dns node
   */
  DnsNode insertDhcpLeases(
      final String zoneName,
      final DnsNode dnsNode) {

<span class="fc" id="L263">    final boolean isReverseZone = dnsZoneRepository.isDnsReverseZone(zoneName);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">    final Map&lt;String, DhcpLease&gt; leaseMap = isReverseZone</span>
<span class="fc" id="L265">        ? dhcpRepository.findActiveByHostName() : dhcpRepository.findActiveByIp();</span>

<span class="fc bfc" id="L267" title="All 2 branches covered.">    for (final DnsRecord record : dnsNode.getRecords()) {</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">      if (DnsRecordType.A.is(record.getRecordType())) {</span>
<span class="fc" id="L269">        record.setDhcpLease(leaseMap.get(record.getRecordValue()));</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">      } else if (DnsRecordType.PTR.is(record.getRecordType())</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">          &amp;&amp; record.getRecordValue().endsWith(&quot;.&quot; + getProperties().getDefaultZone())) {</span>
<span class="fc" id="L272">        final String hostName = record.getRecordValue().substring(</span>
            0,
<span class="fc" id="L274">            record.getRecordValue().length() - (&quot;.&quot; + getProperties().getDefaultZone()).length())</span>
<span class="fc" id="L275">            .toLowerCase();</span>
<span class="fc" id="L276">        record.setDhcpLease(leaseMap.get(hostName));</span>
      }
<span class="fc" id="L278">    }</span>
<span class="fc" id="L279">    return dnsNode;</span>
  }

  /**
   * Insert correlation values dns node.
   *
   * @param zoneName the zone name
   * @param dnsNode the dns node
   * @return the dns node
   */
  DnsNode insertCorrelationValues(
      final String zoneName,
      final DnsNode dnsNode) {
<span class="fc" id="L292">    dnsNode.setRecords(dnsNode.getRecords().stream()</span>
<span class="fc" id="L293">        .map(dnsRecord -&gt; insertCorrelationValue(zoneName, dnsRecord))</span>
<span class="fc" id="L294">        .collect(Collectors.toSet()));</span>
<span class="fc" id="L295">    return dnsNode;</span>
  }

  /**
   * Insert correlation value dns record.
   *
   * @param zoneName the zone name
   * @param dnsRecord the dns record
   * @return the dns record
   */
  DnsRecord insertCorrelationValue(
      final String zoneName,
      final DnsRecord dnsRecord) {
<span class="fc" id="L308">    return findCorrelatedDnsNode(zoneName, dnsRecord)</span>
<span class="fc" id="L309">        .filter(dnsPair -&gt; Boolean.TRUE.equals(dnsPair.getNodeExists()))</span>
<span class="fc" id="L310">        .flatMap(dnsPair -&gt; dnsPair.getNode().getRecords().stream()</span>
<span class="fc" id="L311">            .filter(correlatedRecord -&gt; DnsRecordType.areCorrelated(dnsRecord, correlatedRecord))</span>
<span class="fc" id="L312">            .findAny())</span>
<span class="fc" id="L313">        .map(correlatedRecord -&gt; {</span>
<span class="fc" id="L314">          dnsRecord.setCorrelatedRecordValue(correlatedRecord.getRecordValue());</span>
<span class="fc" id="L315">          return dnsRecord;</span>
        })
<span class="fc" id="L317">        .orElse(dnsRecord);</span>
  }

  @Override
  public Optional&lt;DnsPair&gt; findCorrelatedDnsNode(
      final String zoneName,
      final DnsRecord record) {

<span class="fc bfc" id="L325" title="All 2 branches covered.">    if (DnsRecordType.A.is(record.getRecordType())) {</span>
<span class="fc" id="L326">      final String ip4 = record.getRecordValue();</span>
<span class="fc" id="L327">      return findDnsZoneByIp4(ip4)</span>
<span class="fc" id="L328">          .flatMap(reverseZone -&gt; buildDnsPairByIp4(ip4, reverseZone));</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">    } else if (DnsRecordType.PTR.is(record.getRecordType())) {</span>
<span class="fc" id="L330">      final String fqdn = record.getRecordValue();</span>
<span class="fc" id="L331">      return findDnsZoneByFqdn(fqdn)</span>
<span class="fc" id="L332">          .flatMap(zone -&gt; buildDnsPairByFqdn(fqdn, zone));</span>
    }
<span class="fc" id="L334">    return Optional.empty();</span>
  }

  /**
   * Build dns pair by ip 4 optional.
   *
   * @param ip4 the ip 4
   * @param reverseZone the reverse zone
   * @return the optional
   */
  Optional&lt;DnsPair&gt; buildDnsPairByIp4(
      final String ip4,
      final DnsZone reverseZone) {

<span class="fc" id="L348">    return getDnsNodeNameByIp4(ip4, reverseZone.getName())</span>
<span class="fc" id="L349">        .map(nodeName -&gt; findOne(reverseZone.getName(), nodeName, NO_UNKNOWN, false, false)</span>
<span class="fc" id="L350">            .map(dnsNode -&gt; DnsPair.builder()</span>
<span class="fc" id="L351">                .zoneName(reverseZone.getName())</span>
<span class="fc" id="L352">                .node(dnsNode)</span>
<span class="fc" id="L353">                .nodeExists(true)</span>
<span class="fc" id="L354">                .build())</span>
<span class="fc" id="L355">            .orElseGet(() -&gt; DnsPair.builder()</span>
<span class="fc" id="L356">                .zoneName(reverseZone.getName())</span>
<span class="fc" id="L357">                .node(DnsNode.builder()</span>
<span class="fc" id="L358">                    .name(nodeName)</span>
<span class="fc" id="L359">                    .build())</span>
<span class="fc" id="L360">                .nodeExists(false)</span>
<span class="fc" id="L361">                .build()));</span>
  }

  /**
   * Build dns pair by fqdn optional.
   *
   * @param fqdn the fqdn
   * @param dnsZone the dns zone
   * @return the optional
   */
  Optional&lt;DnsPair&gt; buildDnsPairByFqdn(final String fqdn, final DnsZone dnsZone) {
<span class="fc" id="L372">    return getDnsNodeNameByFqdn(fqdn, dnsZone.getName())</span>
<span class="fc" id="L373">        .map(nodeName -&gt; findOne(dnsZone.getName(), nodeName, NO_UNKNOWN, false, false)</span>
<span class="fc" id="L374">            .map(dnsNode -&gt; DnsPair.builder()</span>
<span class="fc" id="L375">                .zoneName(dnsZone.getName())</span>
<span class="fc" id="L376">                .node(dnsNode)</span>
<span class="fc" id="L377">                .nodeExists(true)</span>
<span class="fc" id="L378">                .build())</span>
<span class="pc" id="L379">            .orElseGet(() -&gt; DnsPair.builder()</span>
<span class="nc" id="L380">                .zoneName(dnsZone.getName())</span>
<span class="nc" id="L381">                .node(DnsNode.builder()</span>
<span class="nc" id="L382">                    .name(nodeName)</span>
<span class="nc" id="L383">                    .build())</span>
<span class="nc" id="L384">                .nodeExists(false)</span>
<span class="nc" id="L385">                .build()));</span>
  }

  @Override
  public boolean delete(final String zoneName, final String nodeName) {
<span class="fc" id="L390">    return findOne(zoneName, nodeName, ALL, false, false)</span>
<span class="fc" id="L391">        .map(node -&gt; delete(zoneName, node))</span>
<span class="fc" id="L392">        .orElse(false);</span>
  }

  @Override
  public void deleteAll(final String zoneName, final Collection&lt;String&gt; nodeNames) {
<span class="pc bpc" id="L397" title="2 of 4 branches missed.">    if (nodeNames != null &amp;&amp; !nodeNames.isEmpty()) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">      for (String nodeName : new LinkedHashSet&lt;&gt;(nodeNames)) {</span>
<span class="fc" id="L399">        findOne(zoneName, nodeName, ALL, false, false)</span>
<span class="fc" id="L400">            .ifPresent(dnsNode -&gt; delete(zoneName, dnsNode));</span>
<span class="fc" id="L401">      }</span>
    }
<span class="fc" id="L403">  }</span>

  /**
   * Handle ptr records.
   *
   * @param zoneName the zone name
   * @param nodeName the node name
   * @param newRecords the new records
   * @param deletedRecords the deleted records
   */
  void handlePtrRecords(
      final String zoneName,
      final String nodeName,
      final Set&lt;DnsRecord&gt; newRecords,
      final Set&lt;DnsRecord&gt; deletedRecords) {

<span class="fc bfc" id="L419" title="All 2 branches covered.">    if (dnsZoneRepository.isDnsReverseZone(zoneName)) {</span>
<span class="fc" id="L420">      return;</span>
    }
<span class="fc bfc" id="L422" title="All 2 branches covered.">    for (final DnsRecord record : deletedRecords) {</span>
<span class="fc" id="L423">      findCorrelatedDnsNode(zoneName, record).ifPresent(pair -&gt; {</span>
<span class="fc" id="L424">        final Set&lt;DnsRecord&gt; records = new LinkedHashSet&lt;&gt;(pair.getNode().getRecords());</span>
<span class="fc" id="L425">        records.remove(DnsRecord.builder()</span>
<span class="fc" id="L426">            .recordType(DnsRecordType.PTR.name())</span>
<span class="fc" id="L427">            .recordValue(nodeName + &quot;.&quot; + zoneName)</span>
<span class="fc" id="L428">            .build());</span>
<span class="fc" id="L429">        final DnsNode node = pair.getNode().toBuilder()</span>
<span class="fc" id="L430">            .records(records)</span>
<span class="fc" id="L431">            .build();</span>
<span class="fc" id="L432">        save(pair.getZoneName(), node);</span>
<span class="fc" id="L433">      });</span>
<span class="fc" id="L434">    }</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">    for (final DnsRecord record : newRecords) {</span>
<span class="fc" id="L436">      findCorrelatedDnsNode(zoneName, record).ifPresent(pair -&gt; {</span>
<span class="fc" id="L437">        final DnsRecord newRecord = DnsRecord.builder()</span>
<span class="fc" id="L438">            .recordType(DnsRecordType.PTR.name())</span>
<span class="fc" id="L439">            .recordValue(nodeName + &quot;.&quot; + zoneName)</span>
<span class="fc" id="L440">            .build();</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">        if (!pair.getNode().getRecords().contains(newRecord)) {</span>
<span class="fc" id="L442">          final Set&lt;DnsRecord&gt; records = new LinkedHashSet&lt;&gt;(pair.getNode().getRecords());</span>
<span class="fc" id="L443">          records.add(newRecord);</span>
<span class="fc" id="L444">          final DnsNode node = pair.getNode().toBuilder()</span>
<span class="fc" id="L445">              .records(records)</span>
<span class="fc" id="L446">              .build();</span>
<span class="fc" id="L447">          save(pair.getZoneName(), node);</span>
        }
<span class="fc" id="L449">      });</span>
<span class="fc" id="L450">    }</span>
<span class="fc" id="L451">  }</span>

  /**
   * Find dns zone by an IPv4.
   *
   * @param ip the IPv4
   * @return the dns zone or {@code empty}
   */
  Optional&lt;DnsZone&gt; findDnsZoneByIp4(final String ip) {
<span class="fc" id="L460">    return dnsZoneRepository.findDnsReverseZones()</span>
<span class="fc" id="L461">        .filter(dnsZone -&gt; ip4MatchesDnsZone(ip, dnsZone.getName()))</span>
<span class="fc" id="L462">        .findFirst();</span>
  }

  /**
   * Find dns zone by fqdn optional.
   *
   * @param fqdn the fqdn
   * @return the optional
   */
  Optional&lt;DnsZone&gt; findDnsZoneByFqdn(final String fqdn) {
<span class="fc" id="L472">    final Map&lt;String, DnsZone&gt; zoneMap = dnsZoneRepository.findNonDnsReverseZones()</span>
<span class="fc" id="L473">        .collect(Collectors.toMap(dnsNode -&gt; dnsNode.getName().toLowerCase(), dnsNode -&gt; dnsNode));</span>
<span class="fc" id="L474">    String tmp = fqdn;</span>
    int i;
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">    while ((i = tmp.indexOf('.')) &gt; -1) {</span>
<span class="fc" id="L477">      final String zoneName = fqdn.substring(i + 1);</span>
<span class="fc" id="L478">      final DnsZone dnsZone = zoneMap.get(zoneName.toLowerCase());</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">      if (dnsZone != null) {</span>
<span class="fc" id="L480">        return Optional.of(dnsZone);</span>
      }
<span class="nc" id="L482">      tmp = zoneName;</span>
<span class="nc" id="L483">    }</span>
<span class="nc" id="L484">    return Optional.empty();</span>
  }

  /**
   * Checks whether the given IPv4 (e. g. {@code 192.168.1.123}) matches the given dns zone name (e.
   * g. {@code 1.168.192.in-addr.arpa}).
   *
   * @param ip the IPv4 (e. g. {@code 192.168.1.123})
   * @param zoneName the dns reverse zone name (e. g. {@code 1.168.192.in-addr.arpa})
   * @return {@code true} if the ip matches the dns reverse zone, otherwise {@code false}
   */
  boolean ip4MatchesDnsZone(final String ip, final String zoneName) {
<span class="pc bpc" id="L496" title="3 of 6 branches missed.">    if (ip == null || zoneName == null || !patternIp4.matcher(ip).matches()) {</span>
<span class="nc" id="L497">      return false;</span>
    }
<span class="fc" id="L499">    return Optional.ofNullable(splitIp4(ip, zoneName))</span>
<span class="fc" id="L500">        .map(ipParts -&gt; ip.equals(ipParts[0] + &quot;.&quot; + ipParts[1]))</span>
<span class="fc" id="L501">        .orElse(false);</span>
  }

  /**
   * Returns the dns reverse node name.
   *
   * @param ip the IPv4 (e. g. {@code 192.168.1.123}
   * @param zoneName the dns reverse zone name (e. g. {@code 1.168.192.in-addr.arpa}
   * @return the dns reverse node name (e. g. {@code 123}
   */
  Optional&lt;String&gt; getDnsNodeNameByIp4(final String ip, final String zoneName) {
<span class="fc" id="L512">    return Optional.ofNullable(splitIp4(ip, zoneName)).map(parts -&gt; parts[1]);</span>
  }

  /**
   * Returns the dns node name.
   *
   * @param fqdn the full qualified domain name (e. g. {@code pluto.eixe.bremersee.org})
   * @param zoneName the dns zone name (e. g. {@code eixe.bremersee.org})
   * @return the dns node name (e. g. {@code pluto})
   */
  Optional&lt;String&gt; getDnsNodeNameByFqdn(final String fqdn, final String zoneName) {
<span class="pc bpc" id="L523" title="2 of 4 branches missed.">    if (fqdn == null || zoneName == null) {</span>
<span class="nc" id="L524">      return Optional.empty();</span>
    }
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">    if (fqdn.toLowerCase().endsWith(&quot;.&quot; + zoneName.toLowerCase())) {</span>
<span class="fc" id="L527">      return Optional.of(fqdn.substring(0, fqdn.length() - (&quot;.&quot; + zoneName).length()));</span>
    }
<span class="nc" id="L529">    return Optional.empty();</span>
  }

  /**
   * Split Ipv4 into parts, e. g. {@code 192.168.1} from the dns reverse zone name and into the node
   * name {@code 123}.
   *
   * @param ip the IPv4 (e. g. {@code 192.168.1.123}
   * @param zoneName the dns reverse zone name (e. g. {@code 1.168.192.in-addr.arpa}
   * @return the Ipv4 parts or {@code null} if the ip doesn't belong to the dns reverse zone
   */
  String[] splitIp4(final String ip, final String zoneName) {
<span class="pc bpc" id="L541" title="2 of 4 branches missed.">    if (ip == null || zoneName == null</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        || zoneName.length() &lt;= getProperties().getReverseZoneSuffixIp4().length()</span>
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        || !patternIp4.matcher(ip).matches()) {</span>
<span class="nc" id="L544">      return null;</span>
    }
<span class="fc" id="L546">    final String ipPart = zoneName.substring(</span>
        0,
<span class="fc" id="L548">        zoneName.length() - getProperties().getReverseZoneSuffixIp4().length());</span>
<span class="fc" id="L549">    final String[] ipParts = ipPart.split(Pattern.quote(&quot;.&quot;));</span>
<span class="fc" id="L550">    final StringBuilder ipBuilder = new StringBuilder();</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">    for (int i = ipParts.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L552">      ipBuilder.append(ipParts[i]);</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">      if (i &gt; 0) {</span>
<span class="fc" id="L554">        ipBuilder.append('.');</span>
      }
    }
<span class="fc" id="L557">    final String ipPrefix = ipBuilder.toString();</span>
<span class="fc" id="L558">    final String ipPostfix = ip.substring(ipPrefix.length() + 1);</span>
    // ipPrefix is something like 192.168.1
    // ipPostfix is something like 123
    // or
    // ipPrefix is something like 192.168
    // ipPostfix is something like 1.123 // TODO is this correct or do it have to be 123.1 ?
<span class="fc bfc" id="L564" title="All 2 branches covered.">    if (!ip.equals(ipPrefix + &quot;.&quot; + ipPostfix)) {</span>
<span class="fc" id="L565">      return null;</span>
    }
<span class="fc" id="L567">    return new String[]{ipPrefix, ipPostfix};</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>