<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DnsNodeRepositoryImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dc-con-app</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.dccon.repository</a> &gt; <span class="el_source">DnsNodeRepositoryImpl.java</span></div><h1>DnsNodeRepositoryImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.dccon.repository;

import static org.bremersee.dccon.model.UnknownFilter.ALL;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Stream;
import lombok.extern.slf4j.Slf4j;
import org.bremersee.data.ldaptive.LdaptiveEntryMapper;
import org.bremersee.data.ldaptive.LdaptiveTemplate;
import org.bremersee.dccon.config.DomainControllerProperties;
import org.bremersee.dccon.model.DnsNode;
import org.bremersee.dccon.model.DnsRecord;
import org.bremersee.dccon.model.UnknownFilter;
import org.bremersee.dccon.repository.cli.CommandExecutor;
import org.bremersee.dccon.repository.ldap.DnsNodeLdapMapper;
import org.bremersee.exception.ServiceException;
import org.ldaptive.SearchFilter;
import org.ldaptive.SearchRequest;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.context.annotation.Profile;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

/**
 * The dns node repository.
 *
 * @author Christian Bremer
 */
@Profile(&quot;ldap&quot;)
@Component(&quot;dnsNodeRepository&quot;)
<span class="fc" id="L56">@Slf4j</span>
public class DnsNodeRepositoryImpl extends AbstractDnsNodeRepository {

  private final Map&lt;String, LdaptiveEntryMapper&lt;DnsNode&gt;&gt; dnsNodeLdapMapperMap;

  private DnsNodeLdapMapperProvider dnsNodeLdapMapperProvider;

  /**
   * Instantiates a new dns node repository.
   *
   * @param properties the properties
   * @param ldapTemplateProvider the ldap template provider
   * @param dhcpRepository the dhcp repository
   * @param dnsZoneRepository the dns zone repository
   */
  public DnsNodeRepositoryImpl(
      final DomainControllerProperties properties,
      final ObjectProvider&lt;LdaptiveTemplate&gt; ldapTemplateProvider,
      final DhcpRepository dhcpRepository,
      final DnsZoneRepository dnsZoneRepository) {
<span class="fc" id="L76">    super(properties, ldapTemplateProvider.getIfAvailable(), dhcpRepository, dnsZoneRepository);</span>
<span class="fc" id="L77">    this.dnsNodeLdapMapperMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="pc" id="L78">    this.dnsNodeLdapMapperProvider = (zoneName, unknownFilter) -&gt; new DnsNodeLdapMapper(</span>
<span class="nc" id="L79">        getProperties(), zoneName, unknownFilter);</span>
<span class="fc" id="L80">  }</span>

  /**
   * Keep dhcp lease caches up to date.
   */
  @Scheduled(fixedDelay = 30000L, initialDelay = 2000)
  public void keepDhcpLeaseCachesUpToDate() {
<span class="fc" id="L87">    log.trace(&quot;msg=[Keeping dhcp lease cache up to date.]&quot;);</span>
<span class="fc" id="L88">    getDhcpRepository().findActiveByIp();</span>
<span class="fc" id="L89">    getDhcpRepository().findActiveByHostName();</span>
<span class="fc" id="L90">  }</span>

  private LdaptiveEntryMapper&lt;DnsNode&gt; getDnsNodeLdapMapper(
      final String zoneName,
      final UnknownFilter unknownFilter) {
<span class="fc" id="L95">    final UnknownFilter filter = unknownFilter(unknownFilter);</span>
<span class="fc" id="L96">    final String key = zoneName + &quot;:&quot; + filter.name();</span>
<span class="fc" id="L97">    return dnsNodeLdapMapperMap.computeIfAbsent(</span>
        key,
<span class="fc" id="L99">        k -&gt; dnsNodeLdapMapperProvider.getDnsNodeLdapMapper(zoneName, filter));</span>
  }

  /**
   * Sets dns node ldap mapper provider.
   *
   * @param dnsNodeLdapMapperProvider the dns node ldap mapper provider
   */
  @SuppressWarnings(&quot;unused&quot;)
  public void setDnsNodeLdapMapperProvider(
      final DnsNodeLdapMapperProvider dnsNodeLdapMapperProvider) {
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">    if (dnsNodeLdapMapperProvider != null) {</span>
<span class="fc" id="L111">      this.dnsNodeLdapMapperProvider = dnsNodeLdapMapperProvider;</span>
    }
<span class="fc" id="L113">  }</span>

  @Override
  public Stream&lt;DnsNode&gt; findAll(
      final String zoneName,
      final UnknownFilter unknownFilter,
      final String query) {

<span class="fc" id="L121">    final SearchRequest searchRequest = new SearchRequest(</span>
<span class="fc" id="L122">        getProperties().buildDnsNodeBaseDn(zoneName),</span>
<span class="fc" id="L123">        new SearchFilter(getProperties().getDnsNodeFindAllFilter()));</span>
<span class="fc" id="L124">    searchRequest.setSearchScope(getProperties().getDnsNodeFindAllSearchScope());</span>
<span class="fc" id="L125">    searchRequest.setBinaryAttributes(&quot;dnsRecord&quot;);</span>
<span class="pc bpc" id="L126" title="1 of 4 branches missed.">    if (query == null || query.trim().length() == 0) {</span>
<span class="fc" id="L127">      return getLdapTemplate().findAll(searchRequest, getDnsNodeLdapMapper(zoneName, unknownFilter))</span>
<span class="fc" id="L128">          .filter(this::isNonExcludedDnsNode)</span>
<span class="fc" id="L129">          .map(dnsNode -&gt; insertCorrelationValues(zoneName, dnsNode))</span>
<span class="fc" id="L130">          .map(dnsNode -&gt; insertDhcpLeases(zoneName, dnsNode));</span>
    } else {
<span class="fc" id="L132">      return getLdapTemplate().findAll(searchRequest, getDnsNodeLdapMapper(zoneName, unknownFilter))</span>
<span class="fc" id="L133">          .filter(this::isNonExcludedDnsNode)</span>
<span class="fc" id="L134">          .map(dnsNode -&gt; insertCorrelationValues(zoneName, dnsNode))</span>
<span class="fc" id="L135">          .map(dnsNode -&gt; insertDhcpLeases(zoneName, dnsNode))</span>
<span class="fc" id="L136">          .filter(dnsNode -&gt; this.isQueryResult(dnsNode, query));</span>
    }
  }

  @Override
  public boolean exists(
      final String zoneName,
      final String nodeName,
      final UnknownFilter unknownFilter) {
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">    return isNonExcludedDnsNode(nodeName)</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        &amp;&amp; getDnsZoneRepository().exists(zoneName)</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        &amp;&amp; getLdapTemplate().exists(DnsNode.builder().name(nodeName).build(),</span>
<span class="fc" id="L148">        getDnsNodeLdapMapper(zoneName, unknownFilter));</span>
  }

  @Override
  Optional&lt;DnsNode&gt; findOne(
      final String zoneName,
      final String nodeName,
      final UnknownFilter unknownFilter,
      final boolean withCorrelationValues,
      final boolean withDhcpLeases) {

<span class="fc" id="L159">    final SearchFilter searchFilter = new SearchFilter(getProperties().getDnsNodeFindOneFilter());</span>
<span class="fc" id="L160">    searchFilter.setParameter(0, nodeName);</span>
<span class="fc" id="L161">    final SearchRequest searchRequest = new SearchRequest(</span>
<span class="fc" id="L162">        getProperties().buildDnsNodeBaseDn(zoneName),</span>
        searchFilter);
<span class="fc" id="L164">    searchRequest.setSearchScope(getProperties().getDnsNodeFindAllSearchScope());</span>
<span class="fc" id="L165">    searchRequest.setBinaryAttributes(&quot;dnsRecord&quot;);</span>
<span class="fc" id="L166">    return getLdapTemplate().findOne(searchRequest, getDnsNodeLdapMapper(zoneName, unknownFilter))</span>
<span class="fc" id="L167">        .filter(this::isNonExcludedDnsNode)</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">        .map(dnsNode -&gt; withCorrelationValues</span>
<span class="fc" id="L169">            ? insertCorrelationValues(zoneName, dnsNode)</span>
            : dnsNode)
<span class="fc bfc" id="L171" title="All 2 branches covered.">        .map(dnsNode -&gt; withDhcpLeases</span>
<span class="fc" id="L172">            ? insertDhcpLeases(zoneName, dnsNode)</span>
            : dnsNode);
  }

  @Override
  public Optional&lt;DnsNode&gt; save(
      final String zoneName,
      final DnsNode dnsNode) {

<span class="fc bfc" id="L181" title="All 2 branches covered.">    if (isExcludedDnsNode(dnsNode)) {</span>
<span class="fc" id="L182">      throw ServiceException.badRequest(</span>
          &quot;Node name is not allowed.&quot;,
          &quot;org.bremersee:dc-con-app:8dd7165e-89af-4423-900a-5fc0a71fe7bf&quot;);
    }
    // Collect deleted records and save existing dns node
<span class="fc" id="L187">    final Set&lt;DnsRecord&gt; deletedRecords = new LinkedHashSet&lt;&gt;();</span>
<span class="fc" id="L188">    DnsNode newDnsNode = findOne(zoneName, dnsNode.getName(), ALL, false, false)</span>
<span class="fc" id="L189">        .map(existingDnsNode -&gt; {</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">          for (final DnsRecord existingDnsRecord : existingDnsNode.getRecords()) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (!dnsNode.getRecords().contains(existingDnsRecord)) {</span>
<span class="fc" id="L192">              deletedRecords.add(existingDnsRecord);</span>
            }
<span class="fc" id="L194">          }</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">          if (deletedRecords.size() == existingDnsNode.getRecords().size()) {</span>
<span class="fc" id="L196">            getLdapTemplate().delete(</span>
                existingDnsNode,
<span class="fc" id="L198">                getDnsNodeLdapMapper(zoneName, ALL));</span>
<span class="fc" id="L199">            return DnsNode.builder()</span>
<span class="fc" id="L200">                .name(dnsNode.getName())</span>
<span class="fc" id="L201">                .build();</span>
          }
<span class="fc" id="L203">          return getLdapTemplate().save(dnsNode, getDnsNodeLdapMapper(zoneName, ALL));</span>
        })
<span class="fc" id="L205">        .orElseGet(() -&gt; DnsNode.builder()</span>
<span class="fc" id="L206">            .name(dnsNode.getName())</span>
<span class="fc" id="L207">            .build());</span>

    // Collect new records
<span class="fc" id="L210">    final Set&lt;DnsRecord&gt; newRecords = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">    for (final DnsRecord record : dnsNode.getRecords()) {</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">      if (!newDnsNode.getRecords().contains(record)) {</span>
<span class="fc" id="L213">        newRecords.add(record);</span>
      }
<span class="fc" id="L215">    }</span>

<span class="pc bpc" id="L217" title="1 of 4 branches missed.">    if (newDnsNode.getRecords().isEmpty() &amp;&amp; newRecords.isEmpty()) {</span>
      // The dns node has no records, it will be deleted
<span class="nc bnc" id="L219" title="All 2 branches missed.">      if (StringUtils.hasText(newDnsNode.getDistinguishedName())) {</span>
<span class="nc" id="L220">        getLdapTemplate().delete(dnsNode, getDnsNodeLdapMapper(zoneName, ALL));</span>
      }
<span class="nc" id="L222">      newDnsNode = null;</span>
    } else {
      // Add new record via cli
<span class="fc" id="L225">      add(zoneName, dnsNode.getName(), newRecords);</span>
      // Load dns node from ldap
<span class="fc" id="L227">      newDnsNode = findOne(zoneName, dnsNode.getName(), ALL, false, false)</span>
<span class="pc" id="L228">          .orElseThrow(() -&gt; ServiceException.internalServerError(</span>
              &quot;Saving dns node failed.&quot;,
              &quot;org.bremersee:dc-con-app:7eabb994-f6db-49dc-870b-b4e2dd330a4c&quot;));
    }

    // Do A record to PTR record synchronization
<span class="fc" id="L234">    handlePtrRecords(zoneName, dnsNode.getName(), newRecords, deletedRecords);</span>

<span class="fc" id="L236">    return Optional.ofNullable(newDnsNode);</span>
  }

  /**
   * Add a dns node.
   *
   * @param zoneName the zone name
   * @param nodeName the node name
   * @param records the records
   */
  void add(
      final String zoneName,
      final String nodeName,
      final Collection&lt;DnsRecord&gt; records) {

<span class="nc bnc" id="L251" title="All 8 branches missed.">    if (zoneName == null || nodeName == null || records == null || records.isEmpty()) {</span>
<span class="nc" id="L252">      return;</span>
    }

<span class="nc" id="L255">    kinit();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">    for (final DnsRecord record : records) {</span>
<span class="nc" id="L257">      final List&lt;String&gt; commands = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L258">      sudo(commands);</span>
<span class="nc" id="L259">      commands.add(getProperties().getSambaToolBinary());</span>
<span class="nc" id="L260">      commands.add(&quot;dns&quot;);</span>
<span class="nc" id="L261">      commands.add(&quot;add&quot;);</span>
<span class="nc" id="L262">      commands.add(getProperties().getNameServerHost());</span>
<span class="nc" id="L263">      commands.add(zoneName);</span>
<span class="nc" id="L264">      commands.add(nodeName);</span>
<span class="nc" id="L265">      commands.add(record.getRecordType());</span>
<span class="nc" id="L266">      commands.add(record.getRecordValue());</span>
<span class="nc" id="L267">      auth(commands);</span>
<span class="nc" id="L268">      CommandExecutor.exec(commands, getProperties().getSambaToolExecDir());</span>
<span class="nc" id="L269">    }</span>
<span class="nc" id="L270">  }</span>

  @Override
  public boolean delete(final String zoneName, final DnsNode node) {
<span class="fc bfc" id="L274" title="All 2 branches covered.">    if (isExcludedDnsNode(node)) {</span>
<span class="fc" id="L275">      throw ServiceException.badRequest(</span>
          &quot;Node name is not allowed.&quot;,
          &quot;org.bremersee:dc-con-app:3e377240-eafd-45ea-9ee6-048ab3ca8cec&quot;);
    }
<span class="fc" id="L279">    getLdapTemplate().delete(node, getDnsNodeLdapMapper(zoneName, ALL));</span>
<span class="fc" id="L280">    handlePtrRecords(zoneName, node.getName(), Collections.emptySet(), node.getRecords());</span>
<span class="fc" id="L281">    return true;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>